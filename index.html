<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Nuclear by AlloyTeam</title>
    <link rel="shortcut icon" href="img/nuclear.ico">
    <link href="css/stylesheet.css" rel="stylesheet" />
    <link href="css/code.css" rel="stylesheet" />
    <link href="css/demo.css" rel="stylesheet" />
</head>
<body>
   

    <div class="container">
       
        <div class="nav-main">
            <div class="wrap">
                <a class="nav-home" href="index.html">
                    <img class="nav-logo" src="img/nuclear.png" width="36" height="36">
                    Nuclear
                </a>
                <!--   <ul class="nav-site nav-site-internal">
                  
                   
                </ul>-->

                <ul class="nav-site nav-site-external">
                    <li><a href="https://github.com/AlloyTeam/Nuclear">GitHub</a></li>
                    <li><a href="https://github.com/AlloyTeam/Nuclear/zipball/master">下载</a>

                    </li>
                    <li><a href="http://www.alloyteam.com/">团队博客</a></li>
                    <!--          <li><a href="en.html">English</a></li>-->
                </ul>
            </div>
        </div>



        <div class="hero">
            <div class="wrap">
                <div class="text"><strong>Nuclear</strong></div>
                <div class="minitext">
                   made UI super easy
                </div>

                <div class="buttons-unit">
                    <a href="https://github.com/AlloyTeam/Nuclear" class="button">View on GitHub</a>
                </div>
            </div>
        </div>


        <section class="content wrap">
            
            <section class="light home-section">
                <div class="marketing-row">
                    <div class="marketing-col">
                        <h3>纯粹的javascript</h3>
                        <p>
                            Nuclear不需要jsx，你只需要使用纯粹的javascript就可以使用面向对象的方式去编写各式各样的组件。通过本页面的相关demo和讲解，希望你能够开始愉快地Nuclear之旅吧
                        </p>
                    </div>
                    <div class="marketing-col">
                        <h3>HTML+CSS</h3>
                        <p>
                            Nuclear没有虚拟Dom的概念，完整支持HTML和CSS所有功能，你完全可以使用HTML+CSS进行页面布局排版，放心使用HTML5和CSS3大量的酷炫特性吧
                        </p>
                    </div>
                    <div class="marketing-col">
                        <h3>observejs</h3>
                        <p>
                            Nuclear没有使用诸如EventLoop、requestAnimationFrame、Ticker等定时循环，取而代之的是使用<a href="https://github.com/kmdjs/observejs" target="_blank">observejs</a>进行数据变更监听通知视图全部刷新或者局部刷新，以空间换取时间的方式提高应用程序的性能
                        </p>
                    </div>
                </div>
                    <div class="marketing-row">
                    <div class="marketing-col">
                        <h3>局部CSS</h3>
                        <p>
                        建设ing ，马上就支持了~~~
                        </p>
                    </div>
                    <div class="marketing-col">
                        <h3>任意模板</h3>
                        <p>
                            Nuclear默认采用了mustachejs作为自身的模板引擎。它采用"Logic-less template"（无逻辑模版）的思路，而为了提高模板的可编程性，Nuclear提供了render方法组装拼接模板。也可通过重写Nuclear.Tpl.render使用其他模板引擎。
                        </p>
                    </div>
                    <div class="marketing-col">
                        <h3>松耦合</h3>
                        <p>
                            Nuclear是class base的框架，拥有OO的三大特性封装继承多态，更方便地抽象现实世界的物体及其属性或者逻辑算法。Nuclear的目标是让布局、样式、数据、事件、行为完全独立，让程序更加易维护、可扩展
                        </p>
                    </div>
                </div>
            </section>
            <hr class="home-divider" />
            <section class="home-section">
                <div id="examples">
                    <div class="example">
                        <h3 id="e1">声明式事件绑定</h3>
                        <div  class="todoExample">
                            <div class="playground">
                                <div class="playgroundCode">
                                  <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> TodoApp = Nuclear.create({
    add: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
        evt.preventDefault();
        <span class="hljs-keyword">this</span>.option.items.push(<span class="hljs-keyword">this</span>.textBox.value);
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;\
                    &lt;h3&gt;TODO&lt;/h3&gt;\
                    &lt;ul&gt; {{#items}} &lt;li&gt;{{.}}&lt;/li&gt; {{/items}}&lt;/ul&gt;\
                    &lt;form onsubmit="add(event)" &gt;\
                        &lt;input nc-id="textBox" type="text"  /&gt;\
                        &lt;button&gt;Add #{{items.length}}&lt;/button&gt;\
                    &lt;/form&gt;\
                &lt;/div&gt;'</span>;
    }
});
<span class="hljs-keyword">new</span> TodoApp({ items: [] }, <span class="hljs-string">"#todoListContainer"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                 <div id="todoListContainer"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            以前我们的最佳实践里不建议在dom元素上直接声明事件绑定与调用，因为所调用的方法必定要污染全局某个变量，第二是如果该dom加载完成，而js里定义的事件未加载完成则会报脚本错误。而Nuclear解决了这两大痛点，非常建议和支持声明式事件绑定，Nuclear希望在不丢失语义的前提下，通过最少的代码去书写应用程序。上面的代码，你不用担心<code>onsubmit</code>的<code>add</code>方法的上下文信息，Nuclear会帮你处理好这一切。被调用的<code>add</code>方法就是你在 Nuclear.create中定义的add方法。
                        </p>
                    </div>

                    <div class="example">
                        <h3  id="e3">模板引擎可替换</h3>
<pre class="javascript hljs"><code class="js" >Nuclear.Tpl.render = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tpl, data)</span></span>{
    <span class="hljs-keyword">return</span> template.compile(tpl)(data);
};

<span class="hljs-keyword">var</span> ArtTemplateApp = Nuclear.create({
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;\
                    &lt;h1&gt;{{title}}&lt;/h1&gt;\
                    &lt;ul&gt;\
                    {{each list as value i}}\
                        &lt;li&gt;索引 {{i + 1}} ：{{value}}&lt;/li&gt;\
                    {{/each}}\
                    &lt;/ul&gt;\
                &lt;/div&gt;'</span>;
    }
});

<span class="hljs-keyword">new</span> ArtTemplateApp( {
    title: <span class="hljs-string">'标签'</span>,
    list: [<span class="hljs-string">'文艺'</span>, <span class="hljs-string">'博客'</span>, <span class="hljs-string">'摄影'</span>, <span class="hljs-string">'电影'</span>, <span class="hljs-string">'民谣'</span>, <span class="hljs-string">'旅行'</span>, <span class="hljs-string">'吉他'</span>]
},<span class="hljs-string">"#container"</span>);
</code></pre>

                        <p>通过重写<code>Nuclear.Tpl.render</code>方法使用其他模板引擎。比如上面的例子就是使用artTemplate！</p>
                    </div>

                    <div class="example">
                        <h3 id="e2">无限嵌套</h3>
                        <div  class="todoExample">
                            <div class="playground">
                                <div class="playgroundCode">
                                <pre class="javascript hljs"><code class="JS"><span class="hljs-keyword">var</span> TodoList = Nuclear.create({
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;ul&gt; {{#items}} &lt;li&gt;{{.}}&lt;/li&gt; {{/items}}&lt;/ul&gt;'</span>;
    }
});
<span class="hljs-keyword">var</span> TodoApp = Nuclear.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.todoList = <span class="hljs-keyword">new</span> TodoList({ items: [] })
    },
    add: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
        evt.preventDefault();
        <span class="hljs-keyword">this</span>.todoList.option.items.push(<span class="hljs-keyword">this</span>.textBox.value);
        <span class="hljs-comment">//刷新TodoApp</span>
        <span class="hljs-keyword">this</span>.refresh();
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;\
                    &lt;h3&gt;TODO&lt;/h3&gt;'</span>
                    + <span class="hljs-keyword">this</span>.todoList.render() +
                    <span class="hljs-string">'&lt;form onsubmit="add(event)" &gt;\
                    &lt;input nc-id="textBox" type="text"  /&gt;\
                    &lt;button&gt;Add #'</span>+ <span class="hljs-keyword">this</span>.todoList.option.items.length + <span class="hljs-string">'&lt;/button&gt;\
                    &lt;/form&gt;\
                &lt;/div&gt;'</span>;
    }
});
<span class="hljs-keyword">new</span> TodoApp({}, <span class="hljs-string">"#todoList2Container"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                 <div id="todoList2Container"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            明明是两层嵌套，为什么标题是无限嵌套？我们可以回忆一下我们定义Tree的数据格式可以分为下面两种。
                        </p>
                         <div class="playground">
                          <div class="playgroundCode">
                        <pre class="javascript hljs"><code class="JS"><span class="hljs-keyword">var</span> tree = [
           {
               label: <span class="hljs-string">'A'</span>,
               children: [
                    { label: <span class="hljs-string">'A-B'</span> },
                    {
                        label: <span class="hljs-string">'A-C'</span>, children: [
                           { label: <span class="hljs-string">'A-C-1'</span> }
                        ]
                    },
                  ]
           }, 
           { label: <span class="hljs-string">'B'</span> }
]

<span class="hljs-keyword">var</span> tree = [
           { id: <span class="hljs-number">1</span>, label: <span class="hljs-string">'A'</span>, parentId: <span class="hljs-literal">null</span> },
           { id: <span class="hljs-number">2</span>, label: <span class="hljs-string">'A-B'</span>, parentId: <span class="hljs-number">1</span> },
           { id: <span class="hljs-number">3</span>, label: <span class="hljs-string">'A-C'</span>, parentId: <span class="hljs-number">1</span> },
           { id: <span class="hljs-number">4</span>, label: <span class="hljs-string">'A-C-1'</span>, parentId: <span class="hljs-number">3</span> },
           { id: <span class="hljs-number">5</span>, label: <span class="hljs-string">'B'</span>, parentId: <span class="hljs-literal">null</span> }
]
</code></pre></div> </div>
                        <p>
                            Nulcear使用的是第二种思路。即：看上去永远只有两层嵌套，实际是无限嵌套。再即：我只管我依赖谁，至于你依赖谁我就管不了那么多了。
                        </p>
                    </div>

                       <div class="example">
                        <h3  id="e5">分页组件</h3>
                        <div id="paginationExample">
                            <div class="playground" style="position:relative;">

                                <div class="playgroundCode">
                           <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> Pagination = Nuclear.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.option = Nuclear.merge({
            total: <span class="hljs-number">0</span>,
            pageSize: <span class="hljs-number">10</span>,
            numDisplay: <span class="hljs-number">10</span>,
            currentPage: <span class="hljs-number">3</span>,
            numEdge: <span class="hljs-number">0</span>,
            linkTo: <span class="hljs-string">"#"</span>,
            prevText: <span class="hljs-string">"Prev"</span>,
            nextText: <span class="hljs-string">"Next"</span>,
            ellipseText: <span class="hljs-string">"..."</span>,
            prevShow: <span class="hljs-literal">true</span>,
            nextShow: <span class="hljs-literal">true</span>,
            callback: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; }
        }, <span class="hljs-keyword">this</span>.option);
        <span class="hljs-keyword">this</span>.pageNum = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-keyword">this</span>.option.total / <span class="hljs-keyword">this</span>.option.pageSize);
    },
    onRefresh: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.currentPage &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">this</span>.prev.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
                <span class="hljs-keyword">this</span>.option.currentPage--;
                evt.preventDefault();
            }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
        }
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.currentPage &lt; <span class="hljs-keyword">this</span>.pageNum - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">this</span>.next.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
                <span class="hljs-keyword">this</span>.option.currentPage++;
                evt.preventDefault();
            }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
        }
        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">this</span>.node.querySelectorAll(<span class="hljs-string">".link"</span>);
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        Nuclear.addEvent(<span class="hljs-keyword">this</span>.links, <span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
            self.option.currentPage = <span class="hljs-built_in">parseInt</span>(<span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">"data-pageIndex"</span>));
            evt.preventDefault();
        });
    },
    onOptionChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop, value, oldValue, path)</span> </span>{
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">"currentPage"</span>) {
            <span class="hljs-keyword">this</span>.option.callback(value);
        }
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> tpl = <span class="hljs-string">'&lt;div class="pagination"&gt;'</span>;
        <span class="hljs-keyword">var</span> opt = <span class="hljs-keyword">this</span>.option, interval = <span class="hljs-keyword">this</span>.getInterval();
        <span class="hljs-comment">//上一页</span>
        <span class="hljs-keyword">if</span> (opt.prevShow) {
            tpl += <span class="hljs-keyword">this</span>.getPrev();
        }
        <span class="hljs-comment">//起始点</span>
        <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> &amp;&amp; opt.numEdge &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">var</span> end = <span class="hljs-built_in">Math</span>.min(opt.numEdge, interval[<span class="hljs-number">0</span>]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; end; i++) {
                tpl += <span class="hljs-keyword">this</span>.getItem(i, i + <span class="hljs-number">1</span>);
            }
            <span class="hljs-keyword">if</span> (opt.numEdge &lt; interval[<span class="hljs-number">0</span>] &amp;&amp; opt.ellipseText) {
                tpl += <span class="hljs-string">"&lt;span&gt;"</span> + opt.ellipseText + <span class="hljs-string">"&lt;/span&gt;"</span>;
            }
        }
        <span class="hljs-comment">//内部的链接</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = interval[<span class="hljs-number">0</span>]; i &lt; interval[<span class="hljs-number">1</span>]; i++) {
            tpl += <span class="hljs-keyword">this</span>.getItem(i, i + <span class="hljs-number">1</span>);
        }
        <span class="hljs-comment">// 结束点</span>
        <span class="hljs-keyword">if</span> (interval[<span class="hljs-number">1</span>] &lt; <span class="hljs-keyword">this</span>.pageNum &amp;&amp; opt.numEdge &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pageNum - opt.numEdge &gt; interval[<span class="hljs-number">1</span>] &amp;&amp; opt.ellipseText) {
                tpl += <span class="hljs-string">"&lt;span&gt;"</span> + opt.ellipseText + <span class="hljs-string">"&lt;/span&gt;"</span>;
            }
            <span class="hljs-keyword">var</span> begin = <span class="hljs-built_in">Math</span>.max(<span class="hljs-keyword">this</span>.pageNum - opt.numEdge, interval[<span class="hljs-number">1</span>]);
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = begin; i &lt; <span class="hljs-keyword">this</span>.pageNum ; i++) {
                tpl += <span class="hljs-keyword">this</span>.getItem(i, i + <span class="hljs-number">1</span>);
            }
        }
        <span class="hljs-comment">//下一页</span>
        <span class="hljs-keyword">if</span> (opt.nextShow) {
            tpl += <span class="hljs-keyword">this</span>.getNext();
        }
        tpl += <span class="hljs-string">'&lt;/div&gt;'</span>;
        <span class="hljs-keyword">return</span> tpl;
    },
    getInterval: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> ne_half = <span class="hljs-built_in">Math</span>.ceil(<span class="hljs-keyword">this</span>.option.numDisplay / <span class="hljs-number">2</span>);
        <span class="hljs-keyword">var</span> upper_limit = <span class="hljs-keyword">this</span>.pageNum - <span class="hljs-keyword">this</span>.option.numDisplay;
        <span class="hljs-keyword">var</span> start = <span class="hljs-keyword">this</span>.option.currentPage &gt; ne_half ? <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.option.currentPage - ne_half, upper_limit), <span class="hljs-number">0</span>) : <span class="hljs-number">0</span>;
        <span class="hljs-keyword">var</span> end = <span class="hljs-keyword">this</span>.option.currentPage &gt; ne_half ? <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.option.currentPage + ne_half, <span class="hljs-keyword">this</span>.pageNum) : <span class="hljs-built_in">Math</span>.min(<span class="hljs-keyword">this</span>.option.numDisplay, <span class="hljs-keyword">this</span>.pageNum);
        <span class="hljs-keyword">return</span> [start, end];
    },
    getPrev: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.currentPage === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;span nc-id="prev" class="current prev"&gt;{{prevText}}&lt;/span&gt;'</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;a nc-id="prev" href="{{linkTo}}" class="prev"&gt;{{prevText}}&lt;/a&gt;'</span>;
    },
    getNext: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.currentPage === <span class="hljs-keyword">this</span>.pageNum - <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;span nc-id="next" class="current next"&gt;{{nextText}}&lt;/span&gt;'</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;a nc-id="next" href="{{linkTo}}" class="next"&gt;{{nextText}}&lt;/a&gt;'</span>;
    },
    getItem: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(pageIndex, text)</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.currentPage === pageIndex) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;span class="current"&gt;'</span> + text + <span class="hljs-string">'&lt;/span&gt;'</span>;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;a class="link" data-pageIndex="'</span> + pageIndex + <span class="hljs-string">'" href="{{linkTo}}"&gt;'</span> + text + <span class="hljs-string">'&lt;/a&gt;'</span>;
    }
})

<span class="hljs-keyword">new</span> Pagination({
    total: <span class="hljs-number">100</span>,<span class="hljs-comment">//总个数80</span>
    pageSize: <span class="hljs-number">10</span>, <span class="hljs-comment">//每页显示10项</span>
    numEdge: <span class="hljs-number">1</span>, <span class="hljs-comment">//边缘页数</span>
    numDisplay: <span class="hljs-number">4</span>, <span class="hljs-comment">//主体页数</span>
    callback: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(currentIndex)</span> </span>{ }
}, <span class="hljs-string">"#paginationContainer"</span>);
</code></pre>
                                </div>
                                   <div id="paginationContainer" style="position:absolute;left:610px;top:20px;"></div>
                      
                            </div>

                        </div>
                        <p>
                            这个分页使用了非常多的Nuclear特性。这个例子代码量确实不少，而且大量的模板拼接。许多人会吐槽：“拼字符串”真的好吗？这里需要特别说明一下。
                            <code> mustache.js</code>是logic-less的模板，意思就是专注于渲染，而不建议参杂逻辑的代码在模板里。这是Nuclear选择使用mustache.js的重要原因，因为render方法本身提供了模板的可编程性，所以模板引擎本身不再需要其需要大量的逻辑代码。这也是Nuclear仅仅只有6k的原因。而当我们渲染需要与逻辑紧密关联的时候，模板无法提供更好的表达能力，所以才会出现大量的模板拼接，这并没有什么坏处，仅仅使用模板（任意模板引擎）是无法完成上面功能。上面的render方法内，从上一页、起始点、内部的链接、结束点、下一下，层次非常清晰。<code>Nuclear.merge</code>跟$.extend一样的效果，可以用来合并默认配置，如果你熟悉jQuery的extend,你就知道<code>Nuclear.merge</code>怎么使用。
                        </p>
                    </div>

                       <div class="example">
                        <h3  id="e6">轮播组件</h3>
                        <div id="carouselExample">
                            <div class="playground">

                                <div class="playgroundCode">
                <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> Carousel = Nuclear.create({
    installed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.links = <span class="hljs-keyword">this</span>.nav.querySelectorAll(<span class="hljs-string">'a'</span>);
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        Nuclear.addEvent(<span class="hljs-keyword">this</span>.links, <span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            self.option.index = <span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">"data-index"</span>);
        });
        <span class="hljs-keyword">this</span>.active();
    },
    active: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        Nuclear.removeClass(<span class="hljs-keyword">this</span>.links, <span class="hljs-string">"active"</span>);
        Nuclear.addClass(<span class="hljs-keyword">this</span>.links[<span class="hljs-keyword">this</span>.option.index], <span class="hljs-string">"active"</span>);
    },
    onOptionChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop, value, oldValue, path)</span> </span>{
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">"index"</span>) {
            <span class="hljs-keyword">this</span>.carouselScroll.style.left = value * -<span class="hljs-number">100</span> + <span class="hljs-string">"%"</span>;
            <span class="hljs-keyword">this</span>.active();
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> imgCount = <span class="hljs-keyword">this</span>.option.imgs.length;
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div class="nuclear-carousel"&gt;\
                    &lt;div style="width: '</span> + imgCount * <span class="hljs-number">100</span> + <span class="hljs-string">'%; left: '</span> + <span class="hljs-keyword">this</span>.option.index * -<span class="hljs-number">100</span> + <span class="hljs-string">'%;" nc-id="carouselScroll" class="nuclear-carousel-box"&gt;\
                        {{#imgs}}&lt;img style=" width:'</span>+ <span class="hljs-number">100</span> / imgCount + <span class="hljs-string">'%;" src="{{.}}" /&gt; {{/imgs}}\
                    &lt;/div&gt;\
                    &lt;div nc-id="nav"  class="nuclear-nav"&gt; \
                        {{#imgs}}&lt;a data-index="{{@index}}"&gt;&lt;/a&gt; {{/imgs}}&lt;/div&gt;\
                &lt;/div&gt;'</span>;
    }
});
<span class="hljs-keyword">new</span> Carousel({
    imgs: [<span class="hljs-string">"img/room.jpg"</span>, <span class="hljs-string">"img/sleep.jpg"</span>, <span class="hljs-string">"img/watch.jpg"</span>],
    index: <span class="hljs-number">0</span>
}, <span class="hljs-string">"#carouselContainer"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                    <div id="carouselContainer"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            <code>installed</code>代表dom元素生成到它的容器内由Nuclear自动执行。<code>onOptionChange</code>代表组件的配置发生变更时Nuclear自动执行。模板里使用了<code>nc-id="carouselScroll"</code>和<code>nc-id="nav"</code>自动查询dom，在组件方法里面，可通过<code>this.carouselScroll</code>和<code>this.nav</code>可以直接访问该dom元素。
                        </p>
                      
                    </div>


                      <div class="example">
                        <h3  id="e7">Alert组件</h3>
                        <div id="alertExample">
                            <div class="playground">

                                <div class="playgroundCode">
                                <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> Alert = Nuclear.create({
    hide: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
        <span class="hljs-keyword">this</span>.option.display = <span class="hljs-literal">false</span>;
        evt.stopPropagation();
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.option.display) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;\
                    &lt;div class="ui-mask" style="height:'</span> + (<span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">document</span>.body.scrollHeight, <span class="hljs-built_in">document</span>.body.clientHeight) - <span class="hljs-number">1</span>) + <span class="hljs-string">'px;"&gt;&lt;/div&gt;\
                    &lt;div class="ui-dialog" style="top:'</span> + ((<span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-built_in">document</span>.documentElement.scrollTop) + <span class="hljs-built_in">window</span>.innerHeight / <span class="hljs-number">2</span>) + <span class="hljs-string">'px"&gt;\
                        &lt;div class="ui-dialog-title"&gt;\
                            &lt;h3&gt;{{title}}&lt;/h3&gt;\
                        &lt;/div&gt;\
                        &lt;div class="ui-dialog-content"&gt;\
                            &lt;div title="{{msg}}"&gt;\
                                &lt;p&gt;{{msg}}&lt;/p&gt;&lt;/div&gt;\
                            &lt;/div&gt;\
                        &lt;div onclick="hide(event)"  class="ui-dialog-btns"&gt;&lt;a class="ui-btn ui-btn-1"&gt;好&lt;/a&gt;\
                        &lt;/div&gt;\
                    &lt;/div&gt;\
                &lt;/div&gt;'</span>;
    }
});

$.alert = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(msg, title)</span> </span>{
    <span class="hljs-keyword">new</span> Alert({ msg: msg, title: title || <span class="hljs-string">"提示"</span>, display:<span class="hljs-literal">true</span>}, <span class="hljs-string">"body"</span>);
}

<span class="hljs-keyword">new</span> Button({
    text: <span class="hljs-string">"点我试试alert"</span>,
    onClick: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        $.alert(<span class="hljs-string">"Nuclear大法好"</span>);
    }
}, <span class="hljs-string">"#alertContainer"</span>)
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                    <div id="alertContainer"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            你不需要在CSS里为alert的节点定义<code>display:none</code>,那是传统的做法。使用Nuclear的思路是，如果你没有看到它，它确实已经不存在了（HTML结构里面已经能够没有了它）。因为<code>if (!this.option.display) return;</code>代表返回空的模板了。这个例子还用到了Button组件，Button组件可以见下方的例子。
                        </p>
                    </div>

                    <div class="example">
                        <h3  id="e8">选项卡</h3>
                        <div id="tabExample">
                            <div class="playground">
                                <div class="playgroundCode">
               <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> Tab = Nuclear.create({
    onRefresh: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.tabs = <span class="hljs-keyword">this</span>.node.querySelectorAll(<span class="hljs-string">'.nuclear-tab-nav a'</span>);
        <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
        Nuclear.addEvent(<span class="hljs-keyword">this</span>.tabs, <span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            self.option.selectedIndex = Nuclear.getNodeIndex(<span class="hljs-keyword">this</span>);
        });
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">var</span> tpl = <span class="hljs-string">'&lt;div class="nuclear-tab"&gt;\
                        &lt;div class="nuclear-tab-nav"&gt;'</span>, selectedIndex = <span class="hljs-keyword">this</span>.option.selectedIndex;
                <span class="hljs-keyword">this</span>.option.tabs.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(tab, index)</span> </span>{
                    tpl += <span class="hljs-string">'&lt;a class="'</span> + (selectedIndex === index ? <span class="hljs-string">"nuclear-tab-navActive"</span> : <span class="hljs-string">""</span>) + <span class="hljs-string">'"&gt;'</span> + tab.title + <span class="hljs-string">'&lt;/a&gt;'</span>;
                }.bind(<span class="hljs-keyword">this</span>));
                tpl += <span class="hljs-string">'&lt;/div&gt;\
                        &lt;div class="nuclear-tab-content"&gt;\
                            &lt;div&gt;'</span> + <span class="hljs-keyword">this</span>.option.tabs[selectedIndex].content + <span class="hljs-string">'&lt;/div&gt;\
                        &lt;/div&gt;\
                    &lt;/div&gt;'</span>;
        <span class="hljs-keyword">return</span> tpl;
    }
});

<span class="hljs-keyword">new</span> Tab({
    tabs: [
           { title: <span class="hljs-string">"tab1"</span>, content: <span class="hljs-string">"tab1-content"</span> },
           { title: <span class="hljs-string">"tab2"</span>, content: <span class="hljs-string">'&lt;a href="##"&gt;tab2-content&lt;/a&gt;'</span> },
           { title: <span class="hljs-string">"tab3"</span>, content: <span class="hljs-string">"&lt;em&gt;tab3-content&lt;/em&gt;"</span> }
          ],
    selectedIndex: <span class="hljs-number">0</span>
}, <span class="hljs-string">"#tabContainer"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview" style="padding:0;">
                                    <div id="tabContainer"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            这是一个选项卡的例子。传统的jQuery方式开发选项卡，是先写好所有的导航和内容，点击导航，显示对应的内容，隐藏其余的内容。<br/>Nuclear的理念是先提取出选项卡的状态（selectedIndex ）,不同的状态决定了不同的视图。你看到的元素，就代表了Dom元素的个数。
                        </p>
                         <p>
                            总结<br/>jQuery的方式：每个tab下有对应的Div，显示一个被激活的，其余的隐藏。<br/>Nuclear的方式：每次render tab所对应的内容的时候，有且只有一个Div，表示被激活的面板。这样带来了更少的Dom、和更少的CSS。
                        </p>
                    </div>


                       <div class="example">
                        <h3  id="e9">跑马灯</h3>
                        <div id="marqueeExample">
                            <div class="playground">
                                <div class="playgroundCode">
                    <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> Marquee = Nuclear.create({
    installed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.end =-<span class="hljs-number">20</span>+ <span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">window</span>.getComputedStyle(<span class="hljs-keyword">this</span>.scroll)[<span class="hljs-string">"width"</span>])*-<span class="hljs-number">1</span>;
        <span class="hljs-keyword">this</span>.loop = setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>.option.left -= <span class="hljs-number">5</span>;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.left &lt; <span class="hljs-keyword">this</span>.end) <span class="hljs-keyword">this</span>.option.left = <span class="hljs-keyword">this</span>.option.width;
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">100</span>);                
    },
    onOptionChange: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(prop, value, oldValue, path)</span> </span>{
        <span class="hljs-keyword">if</span> (prop === <span class="hljs-string">"left"</span>) {
            <span class="hljs-keyword">this</span>.scroll.style.left = value + <span class="hljs-string">"px"</span>;
            <span class="hljs-comment">//return false代表不触发render</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        }
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div style="width:{{width}}px;overflow:hidden;position:relative;"&gt;\
                    &lt;div  style="visibility:hidden;"&gt;a核&lt;/div&gt;\
                    &lt;div nc-id="scroll" style="position:absolute; white-space:nowrap;left:{{left}}px;top:0;"&gt;{{content}}&lt;/div&gt;\
                &lt;/div&gt;'</span>;
    }
})
<span class="hljs-keyword">new</span> Marquee({ width: <span class="hljs-number">480</span>, left: <span class="hljs-number">480</span>, content: <span class="hljs-string">"张三中了 笔记本电脑  李四中了 苹果手机  王五中了 QQ靓号  孙六中了 马尔代夫双人游  "</span> }, <span class="hljs-string">"#container"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview" style="padding:0;">
                                    <div id="marqueeContainer"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            Nuclear可以通过标记<code>nc-id</code>来自动回查询dom，只要标记了，在组件的方法中就可以通过<code>this.标记的id</code>去使用改dom对象。如上面所示的<code>this.scroll</code>就是被标记<code> nc-id="scroll"</code>的dom元素。
                        </p>
                           <p>
                               上面这个跑马灯例子，增加了onOptionChange方法，Nuclear会在option发生改变时候自动帮你执行onOptionChange方法，而不是调用render方法摧毁整个dom。你可以通过onOptionChange携带的参数知道那个属性发生了变更，onOptionChange函数返回false代表不摧毁dom。这个例子去掉onOptionChange方法也能实现同样的效果，Nuclear使用者要权衡执行频率、性能开销自行决定使用哪种方式。
                        </p>
                    </div>
                                                                                           
                    <div class="example">
                        <h3  id="e10">简单的示例</h3>
                        <div id="helloExample">
                            <div class="playground">

                                <div class="playgroundCode">
                                    <pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> HelloMessage = Nuclear.create({
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;Hello , {{name}} !&lt;/div&gt;'</span>;
    }
})
<span class="hljs-keyword">new</span> HelloMessage( { name: <span class="hljs-string">"Nuclear"</span> }, <span class="hljs-string">"#helloContainer"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                    <div id="helloContainer"></div>
                                </div>
                            </div>

                        </div>
                        <p>
                            Nuclear通过<code> Nuclear.create</code>方法创建结构型组件,使用<code> Nuclear.createAction</code>创建非结构型组件，这个例子就是结构型组件。
                        </p>
                        <p>
                            创建结构型必须包含 <code>render()</code> 方法，该方法返回渲染的模板，Nuclear使用<a href="https://github.com/janl/mustache.js" target="_blank">mustache.js</a>作为模板渲染引擎，创建组件<code>new HelloMessage</code>的第一个参数是提供给模板引擎的数据，第二个参数是组件的容器，并且可以任何方法都可通过<code>this.option</code>访问该数据。
        
                        </p>
                    </div>
                    <div class="example">
                        <h3  id="e11">有配置的组件</h3>
                        <div id="timerExample">

                            <div class="playground">

                                <div class="playgroundCode">
                                    <pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> Timer = Nuclear.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//react这里不需要加bind(this),会导致对javascript上下文的误解</span>
        <span class="hljs-keyword">this</span>.interval = setInterval(<span class="hljs-keyword">this</span>.tick.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">1000</span>);
    },
    tick: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.option.secondsElapsed++;
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">' &lt;div&gt;Seconds Elapsed: {{secondsElapsed}}&lt;/div&gt;'</span>;
    }
});

<span class="hljs-keyword">new</span> Timer({ secondsElapsed: <span class="hljs-number">0</span> },<span class="hljs-string">"#timerContainer"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                    <div id="timerContainer"></div>
                                </div>


                            </div>
                        </div>
                        <p>
                            Nuclear通过<code>install</code>方法来初始化一些属性或者行为。
        
                        </p>
                    </div>


                    <div class="example">
                        <h3  id="e12">Todo应用</h3>
                        <div class="todoExample">

                            <div class="playground">
                                <div class="playgroundCode">
                             <pre class="javascript hljs"><code class="js"><span class="hljs-keyword">var</span> TodoApp = Nuclear.create({
    onRefresh: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{   
        <span class="hljs-keyword">this</span>.form.addEventListener(<span class="hljs-string">"submit"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
            evt.preventDefault();                
            <span class="hljs-keyword">this</span>.option.items.push(<span class="hljs-keyword">this</span>.textBox.value);
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
       <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;\
                 &lt;h3&gt;TODO&lt;/h3&gt;\
                &lt;ul&gt; {{#items}} &lt;li&gt;{{.}}&lt;/li&gt; {{/items}}&lt;/ul&gt;\
                  &lt;form nc-id="form" &gt;\
                   &lt;input nc-id="textBox" type="text"  /&gt;\
                   &lt;button&gt;Add #{{items.length}}&lt;/button&gt;\
                 &lt;/form&gt;\
               &lt;/div&gt;'</span>;
    }
});
<span class="hljs-keyword">new</span> TodoApp( { items: [] },<span class="hljs-string">"#container"</span>);
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                    <div id="todoContainer"></div>
                                </div>


                            </div>
                        </div>
                        <p>
                         这个例子也用到了标记<code>nc-id</code>来自动化查找dom的特性，如上面的<code>form</code>和<code>textBox</code>。这里比较让人感觉愉快的地方是，nc-id只要保证组件内部唯一就行，其他组件内可以出现相同的id。Nuclear的通过<code>onRefresh</code>注册了一些回调事件，该事件会在组件被更新之后，由Nuclear自动执行。通过<code> this.option</code>可以访问到用户传进的配置。没接触Nuclear之前很难想象，仅仅十行左右的代码就能实现一个Todo应用吧。
                        </p>
                        <p>
                           Nuclear使用还可使用另外两种方式实现该例子：<br/>通过继承：<a href="https://github.com/AlloyTeam/Nuclear/blob/master/example/todo2.html" target="_blank">Todo示例2</a><br/>install的时候直接创建并共享一个option：<a href="https://github.com/AlloyTeam/Nuclear/blob/master/example/todo3.html" target="_blank">Todo实例3</a><br/>install的时候直接创建并且切断observe树：<a href="https://github.com/AlloyTeam/Nuclear/blob/master/example/todo4.html" target="_blank">Todo实例4</a>
                        </p>
                    </div>

                    <div class="example">
                        <h3  id="e13">Markdown编辑器</h3>
                        <div id="markdownExample">

                            <div class="playground">

                                <div class="playgroundCode">
                                    <pre class="javascript hljs"><code class="javascript"><span class="hljs-keyword">var</span> MarkdownEditor = Nuclear.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.option.html = marked(<span class="hljs-keyword">this</span>.option.value);
    },
     installed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.textarea = <span class="hljs-keyword">this</span>.node.querySelector(<span class="hljs-string">"textarea"</span>);
        <span class="hljs-keyword">this</span>.textarea.addEventListener(<span class="hljs-string">"keyup"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>.option.html = marked(<span class="hljs-keyword">this</span>.textarea.value);
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
    },
    onRefresh: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.content = <span class="hljs-keyword">this</span>.node.querySelector(<span class="hljs-string">".content"</span>);
        <span class="hljs-keyword">this</span>.content.style.cursor =<span class="hljs-string">"pointer"</span> ;
        <span class="hljs-keyword">this</span>.content.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">this</span>.content.style.backgroundColor = <span class="hljs-keyword">"#A5E4F5"</span>;
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div&gt;\
                    &lt;h3&gt;Input&lt;/h3&gt;\
                    &lt;textarea rows="15" cols="35"&gt;{{value}}&lt;/textarea&gt;\
                    &lt;h3&gt;Output&lt;/h3&gt;\
                    &lt;div class="content" nc-refresh &gt;\
                        {{{html}}}\
                    &lt;/div&gt;\
                &lt;/div&gt;'</span>;

    }
});

<span class="hljs-keyword">new</span> MarkdownEditor({ value: <span class="hljs-string">'Type some *markdown* here!'</span>, html: <span class="hljs-string">''</span> },<span class="hljs-string">"#markdownContainer"</span>)
</code></pre>
                                </div>
                                <div class="playgroundPreview">
                                    <div id="markdownContainer"></div>
                                </div>


                            </div>
                        </div>
                        <p>
                            Nuclear使用了第三方的markedjs。可以看到，Nuclear可以很轻松和任何框架/库搭配使用。Nuclear通过标记<code>nc-refresh</code>来配置需要局部刷新的地方。
                        </p>

                    </div>
       
                        
                <div class="example">
                    <h3  id="e16">动态模板渲染</h3>
                    <div id="progressExample">
                        <div class="playground">
                            <div class="playgroundCode">
                            <pre class="javascript hljs"><code class="Javascript"><span class="hljs-keyword">var</span> Progress = Nuclear.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.option.percent = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.value * <span class="hljs-number">100</span> + <span class="hljs-string">"%"</span>;
        }
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.displayNumber) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div class="progress"&gt;\
                       &lt;div style="width:{{percent}};" class="progress-bar progress-bar-primary"&gt;{{percent}}&lt;/div&gt;\
                    &lt;/div&gt;'</span>;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;div class="progress"&gt;\
                       &lt;div style="width:{{percent}};" class="progress-bar progress-bar-primary"&gt;&lt;/div&gt;\
                    &lt;/div&gt;'</span>;
        }
    }
})

<span class="hljs-keyword">var</span> progress = <span class="hljs-keyword">new</span> Progress({ value: <span class="hljs-number">0.6</span>, displayNumber: <span class="hljs-literal">true</span> },<span class="hljs-string">"#progressContainer"</span>);
<span class="hljs-comment">//操作数据自动刷新Dom</span>
progress.option.value = <span class="hljs-number">0.3</span>;
<span class="hljs-keyword">var</span> progress = <span class="hljs-keyword">new</span> Progress( { value: <span class="hljs-number">0.6</span>, displayNumber: <span class="hljs-literal">false</span> },<span class="hljs-string">"#progressContainer2"</span>);
</code></pre>
                            </div>
                            <div class="playgroundPreview">
                                <div id="progressContainer"></div>
                                 <div id="progressContainer2"></div>
                            </div>
                        </div>

                    </div>

                    <p>
                        Nuclear通过<code> render</code>方法输出渲染的模板，该方法可以根据option的配置或者某些逻辑动态得拼接或者切换模板，可编程性得到了大大地提高。这个例子只是简单得说明Nuclear有这个能力，上面这个功能使用一个模板也能够实现。
                    </p>

                </div>




                <div class="example">
                    <h3  id="e17">组件继承</h3>
                    <div id="buttonExample">
                        <div class="playground">
                            <div class="playgroundCode">
                                <pre class="javascript hljs"><code class="Javascript"><span class="hljs-keyword">var</span> Button = Nuclear.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.option.disable = <span class="hljs-literal">false</span>;
    },
    installed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.node.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.onClick) {
                <span class="hljs-keyword">this</span>.option.onClick.call(<span class="hljs-keyword">this</span>.node, evt);
            }
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
    },
    render: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">' &lt;a class="btn {{#disable}}disable{{/disable}}"&gt;{{text}}&lt;/a&gt;'</span>;
    }
})

<span class="hljs-keyword">var</span> SwitchButton = Button.create({
    installed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.node.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
            <span class="hljs-keyword">this</span>.option.disable = !<span class="hljs-keyword">this</span>.option.disable;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.disable) {
                <span class="hljs-keyword">this</span>.option.close &amp;&amp; <span class="hljs-keyword">this</span>.option.close();
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">this</span>.option.open &amp;&amp; <span class="hljs-keyword">this</span>.option.open();
            }
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
    }
})

<span class="hljs-keyword">var</span> CountdownButton = Button.create({
    install: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//可通过访问父类方法</span>
        <span class="hljs-comment">// this._super();              </span>
    },
    installed: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">this</span>.node.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.option.disable) {
                <span class="hljs-keyword">this</span>.option.textBak = <span class="hljs-keyword">this</span>.option.text;
                <span class="hljs-keyword">this</span>.option.valueBak = <span class="hljs-keyword">this</span>.option.value;
                <span class="hljs-keyword">this</span>.option.value--;
                <span class="hljs-keyword">this</span>.option.text = <span class="hljs-keyword">this</span>.option.waitingText.replace(<span class="hljs-string">"{}"</span>, <span class="hljs-keyword">this</span>.option.value);
                <span class="hljs-keyword">this</span>.option.disable = !<span class="hljs-keyword">this</span>.option.disable;
                <span class="hljs-keyword">this</span>.interval = setInterval(<span class="hljs-keyword">this</span>.tick.bind(<span class="hljs-keyword">this</span>), <span class="hljs-number">1000</span>);
            }
        }.bind(<span class="hljs-keyword">this</span>), <span class="hljs-literal">false</span>);
    },
    tick: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.value === <span class="hljs-number">1</span>) {
            <span class="hljs-keyword">this</span>.option.disable = !<span class="hljs-keyword">this</span>.option.disable;
            clearInterval(<span class="hljs-keyword">this</span>.interval);
            <span class="hljs-keyword">this</span>.option.text = <span class="hljs-keyword">this</span>.option.textBak;
            <span class="hljs-keyword">this</span>.option.value = <span class="hljs-keyword">this</span>.option.valueBak;
            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.option.complete) <span class="hljs-keyword">this</span>.option.complete();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.option.value--;
            <span class="hljs-keyword">this</span>.option.text = <span class="hljs-keyword">this</span>.option.waitingText.replace(<span class="hljs-string">"{}"</span>, <span class="hljs-keyword">this</span>.option.value);
        }
    }
})

<span class="hljs-keyword">new</span> Button(
    {
        text: <span class="hljs-string">"普通按钮"</span>,
        onClick: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(evt)</span> </span>{
            alert(<span class="hljs-number">1</span>);
        }
    },<span class="hljs-string">"#buttonContainer"</span>);

<span class="hljs-keyword">new</span> SwitchButton(
    {
        text: <span class="hljs-string">"开关按钮"</span>,
        open: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ },
        close: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ }
    },<span class="hljs-string">"#switchButtonContainer"</span>);

<span class="hljs-keyword">new</span> CountdownButton(
     {
         text: <span class="hljs-string">"获取短信验证码"</span>,
         waitingText: <span class="hljs-string">"{}秒后可以重试"</span>,
         value: <span class="hljs-number">10</span>,
         complete: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ }
     },<span class="hljs-string">"#countdownButtonContainer"</span>);
</code></pre>
                            </div>
                            <div class="playgroundPreview">
                                <div id="buttonGroup">
                                    <div id="buttonContainer"></div>
                                    <div id="switchButtonContainer"></div>
                                    <div id="countdownButtonContainer"></div>
                                </div>

                            </div>
                        </div>

                    </div>

                    <p>
                        Nuclear通过<code> Button.create</code>方法实现组件的继承，继承自Button组件。可以看到子类没有定义render方法，因为它们可以共用一套模板。当然，你也可以重新定义render，也可以通过<code> this._super()</code>访问父类的方法。
                    </p>

                </div>
          
                </div>















            </section>
            <hr class="home-divider" />
            <section class="home-bottom-section">
                <div class="buttons-unit">
                    <a href="https://github.com/AlloyTeam/Nuclear" class="button">View on GitHub</a>
                    <a href="https://github.com/AlloyTeam/Nuclear/zipball/master" class="button">Download Nuclear</a>
                </div>
            </section>


        </section>


        <footer class="wrap">

            <div class="center">
                &copy; 2014&ndash;2015 AlloyTeam Inc.<br>
            </div>
        </footer>
    </div>
    <script src="js/marked.min.js"></script>
    <script src="js/nuclear.min.js"></script>
    <script src="js/drag.js"></script>
    <script src="js/layout.js"></script>
    <script src="js/demo.js"></script>
</body>
</html>
